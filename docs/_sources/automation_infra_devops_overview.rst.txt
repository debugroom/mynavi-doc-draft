.. include:: module.txt

.. _section-automation-infra-devops-overview-label:

基盤構築・デプロイの自動化
==================================================================

はじめに
------------------------------------------------------------------

本章では基盤・デプロイの自動化に関する最近の動向および、
基盤自動化・継続的インテグレーション・デリバリを実際に実現する例について概要を説明する。本章は以下の構成から成る。

.. contents:: 本章の構成
   :depth: 2

まず最初に基盤自動化、継続的インテグレーション・デリバリの発展経緯を記載し、近年の動向を整理する。
その後、マイクロサービスアーキテクチャに基づいた実現例の概要を述べる。
実際のアプリケーション構成や想定する基盤の環境、一連のリリースサイクルを具体化して記述するが、実際の設定や実装について次回以降、詳述していく。
なお、次回以降は以下のような章構成の予定である。

* `アプリケーション基本構成・実装例 <https://github.com/debugroom/sample-aws-ecs>`_
* `AWS CodeBuildの実装 <https://github.com/debugroom/sample-aws-codebuild>`_ ・ `AWS CodeBuildの設定例 <https://debugroom.github.io/doc/cloud/aws/article/devops.html#codebuild>`_
* `AWS CodePipelineの実装 <https://github.com/debugroom/sample-aws-codepipeline>`_  ・ `AWS CodePipelineの設定例 <https://debugroom.github.io/doc/cloud/aws/article/devops.html#codepipeline>`_
* AWS CloudFormationの実装例・設定例
* [別途整理中：付録] `モノリシック <https://github.com/debugroom/mynavi-ib-monolithic>`_ ・マイクロサービスアプリケーションの設計・実装の比較(インターネットバンキングを例にして考察)

|br|

基盤構築自動化の発展経緯
------------------------------------------------------------------

|br|
ロードバランサやアプリケーションサーバ、データベースサーバ、監視サーバといったアプリケーション実行基盤を
自動構築するニーズは、仮想化技術の進展とともに、Amazon Web ServiceといったIaaSや、
Openstackなどのクラウドコンピューティングオープンソースソフトウェアの登場により高まりをみせてきた。

従来、企業が自社のデータセンタへ各々サーバを構成し、環境を構築する場合は一度環境を作ってしまえば、その後、ゼロから作り替えたりするケースは稀であった。
しかし、IaaSなどのクラウド環境で、仮想マシン上にゲストOSを `プロビジョニング <https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AD%E3%83%93%E3%82%B8%E3%83%A7%E3%83%8B%E3%83%B3%E3%82%B0>`_ して環境を構築する形になると、
繰り返し、同一の実行基盤サーバ設定、環境を構築することになる。また、オートスケールなど、サーバリソースを動的に増減できることは、
環境の新規構築・破棄が自動で行われ、 `イミュータブルインフラストラクチャ <https://ja.wikipedia.org/wiki/Immutable_Infrastructure>`_ といった概念(一度サーバ環境を構築した後は、特に変更など加えず、破棄して新しく作り変える考え方)で、
アプリケーション実行環境構築手法に新たな考え方をもたらしている。こうした背景のもと、
環境構築の作業品質や実行スピードの向上を目的に、基盤構築作業をコード化して実行すること(Infrastructure As Code)により、
サーバ・ミドルウェア環境を自動構築できる、「Puppet」、「Ansible」、「Chef」といった構成管理ツールが普及していくようになる。

一方、仮想化技術は発展を続け、OSを丸ごと実行するハイパーバイザ型と比べて、ハードウェアリソースの消費コストが小さい
Dockerなどのコンテナ技術が発達し、近年広く普及しつつある。また、Kubernetesなどの
コンテナのリソース管理・スケール調整などを行い、大規模なコンテナアプリケーション実行環境を管理する
オーケストレションツールが脚光を浴びている。このようなアプリケーション実行環境全体の包括的な
Infrastructure As Codeのツールとして、「Amazon Cloud Formation」や「Terraform」を使った
基盤構築のコード化が近年のトレンドとなっている。

|br|


継続的インテグレーション、継続的デリバリの発展
-------------------------------------------------------------------------------------------------------

|br|

他方、継続的インテグレーション(Continuous Integration:CI)・継続的デリバリ(Continuous Delivery:CD)では、
オープンソースソフトウェアのJenkinsを中心として、

#. GitHubなどのソースコードチェックアウト
#. Maven/Gradleなどのビルドツールの実行
#. JUnitなどのテストコードを用いたテスト実行
#. 静的解析ツールを用いたインスペクション
#. 商用環境サーバやライブラリ管理ツールへのデプロイ

といった一連のソフトウェア開発・リリースサイクルを自動化する手法が主流として発展してきたが、
こちらも仮想化技術やコンテナ技術の普及により、ベアメタルサーバをベースとした単一のサーバ環境だけに留まらなくなってきている。
また、ブルーグリーンデプロイメントといった、クラウド環境のメリットを生かして、ローリングアップデートするリリース手法に加え、
マルチコンテナ化により複雑化するCI/CD実行環境からステージング環境・プロダクション環境への一連のリリースサイクルをパイプライン化して可視化する、
AWS CodePipelineなどのツールも活用の機会が増えつつある。

|br|

マイクロサービスにおける基盤自動化・継続的インテグレーション・デリバリ
-------------------------------------------------------------------------------------------------------------------------------------

|br|

こうした状況の中で、疎結合性・独立性を重視し、開発のアジリティを向上させるマイクロサービスアーキテクチャが
基盤構築の自動化・継続的インテグレーションにも変化をもたらしている。というのも、従来のモノリシックなアプリケーション
(全ての機能が一つのアプリケーションパッケージにまとまっている形)に比べ、アプリケーション構成はもとより、
チーム間での開発体制からリリースの単位までこれまでとは異なる形で行うことを要求されるからである。
マイクロサービスアーキテクチャでは、サービス間で影響を局所化し、開発におけるアジリティ向上を実現するために、
以下のようにアプリケーションを構成・開発することが要求されるケースが多い。

* アプリケーションは複数のマイクロサービスで構成する。各サービス単位にチームが分けられ、リリース・デプロイまでの開発プロセスを独立して構築する。
* 多数のサービスはコンテナをベースに構築され、各サービスそれぞれがスケーリング可能な形でデプロイされる。

こうした近年のトレンドに基づき、マイクロサービスアーキテクチャのアプリケーション構成、基盤自動化/継続的インテグレーション・デリバリを実現する例を実際に構築してみよう。

.. figure:: img/automation_infra_devops_overview/MicroServiceArchitecture.png
   :scale: 100%

[アプリケーションの構成]

* アプリケーションはAmazon Web Service上に構築するWebアプリケーションとする。
* アプリケーションはフロントエンドとバックエンドのサービスに分割し、各サービスはAWS ECSコンテナ上にデプロイされるものとする。
* ECSコンテナ内の各サービスは組み込みTomcatを内蔵するSpringBootアプリケーションで実装する。
* 各サービス間はRESTベースのHTTPリクエストでメッセージ通信を行い、ApplicationLoadBalancerを介して負荷分散する。

なお、サービスをフロントエンドとバックエンドに分割するのは以下の理由・目的のためである。

[フロントエンドの役割]

* サービスマッピング(IP・ポート)
* ブラウザからHTTPメソッド変換(GET・POST⇔GET・POST・PUT・DELETE・OPTION)
* セッション共有(キャッシュサーバ)
* セキュリティ
   * 認証・認可
   * 入力チェック
   * バックエンドサービスURIの隠蔽
   * クライアント⇔バックエンドの直接アクセス禁止
* クラウド依存処理の集約(S3アクセス等)

[バックエンドの役割]

* RESTfulアーキテクチャインターフェース(GET/POST/PUT/DELETE/OPTIONS)
* Resource Base URI (/api/v1/users/1)
* 冪等性の実現
* ステートレスの実現
* データベースなどセキュリティ的に保護する必要があるリソースへのアクセス

また、サービスがECSコンテナにより管理、ApplicationLoadBalancerを介することで、以下の面がカバーされるようになる。

* ヘルスチェックによるサービス監視
* サービスディスカバリ(ヘルスチェックでNGだと再起動)
* ロードバランシング
* ハードリソース調整/監視(CloudWatch)
* パスベースルーティング

こうしたアプリケーション実行環境の構成は、AWS CloudFormationやTerraformを使って自動構築することができる。
次回以降、SpringBootを使用したアプリケーションの構成や実装、Cloud Formationによる基盤構築の自動化の具体例について詳述していく。

DevOpsとして、下記のように、各サービスを構成するマルチコンテナ環境下でのステージング・
プロダクション環境へのデプロイまでの一連のサイクルを可視化するパイプラインを構成する。

.. figure:: img/automation_infra_devops_overview/ContinuousDeployment.png
   :scale: 100%

AWS CodePipelineを用いて、GitHub上のDevelopブランチへソースコードをコミットもしくはプルリクエストに対し、
AWS CodeBuildを使って、ビルド・テスト・インスペクションを実行し、コンテナイメージを作成して、DockerHub上へプッシュ、
アプリケーションをステージング環境のAWS ECSへデプロイさせる一連の流れを自動化・可視化する。

ステージング環境での検証の後、改めてGitHubのMasterブランチへソースコードをコミットもしくはプルリクエストに対し、
同様にプロダクション環境へのリリースを自動化して行う。

こちらも同様に、次回以降、各プロダクトの設定の要領やポイントについて詳述する。
