.. include:: module.txt

.. _section-automation-infra-devops-overview-label:

基盤構築・デプロイの自動化
==================================================================

基盤構築自動化の発展経緯
------------------------------------------------------------------

商用アプリケーションを実行するための環境、例えば、ロードバランサやアプリケーションサーバ、データベースサーバ、監視サーバといった
アプリケーション実行基盤を自動構築するニーズは、仮想化技術の進展とともに、Amazon Web ServiceといったIaaSや、
Openstackなどのクラウドコンピューティング用のオープンソースソフトウェアにより高まりをみせてきた。

従来、企業が自社のデータセンタへ各々サーバを構成し、アプリケーション実行環境を構築する場合は
一度環境を作ってしまえば、その後、大きく環境を作り替えたり、変更するケースは稀であったが、
IaaSなどのクラウド環境で仮想マシン上のゲストOSをプロビジョニングして環境を構築する形になると、
繰り返し、同一の実行基盤サーバ、環境を構築することになる。また、サーバリソースを動的に追加したり削除したりできることは、
ImmutableInfrastructureといった概念でのアプリケーション実行環境の新たな考え方をもたらしている。こうした背景のもと、
環境構築の作業品質や実行スピードの向上を目的に、InfrastructureAsCodeとして基盤構築をコード化して実行することにより、
環境を自動構築する、「Puppet」、「Ansible」、「Chef」といった構成管理ツールが普及するようになる。

一方、仮想化技術はハイパーバイザ型と比べて、CPU、メモリ、ストレージといったハードウェアリソースの消費コストが小さい
Dockerなどのコンテナ技術が発達し、広く普及しつつある。また、Kubernetesなどの
コンテナのリソース管理、スケール調整などを行い、大規模なアプリケーション実行環境を構築する
オーケストレションツールが脚光を浴びている。こうした環境構築を含めた包括的な
InfrastructureAsCodeとしてのツールとして、「Amazon Cloud Formation」や「Terraform」を使った
基盤構築のコード化が近年のトレンドとなっている。


継続的インテグレーション、継続的デリバリの発展
-------------------------------------------------------------------------------------------------------

継続的インテグレーション(Continuous Integration:CI)・継続的デリバリ(Continuous Delivery:CD)では、
オープンソースソフトウェアのJenkinsを中心として、

#. GitHubなどのソースコードチェックアウト
#. Maven/Gradleなどのビルドツールの実行
#. JUnitなどのテストコードを用いたテスト実行
#. 静的解析ツールを用いたインスペクション
#. 商用環境サーバやライブラリ管理ツールへのデプロイ

といった一連のソフトウェア開発・リリースサイクルを自動化する手法が主流として発展して来たが、
こちらも仮想化技術やコンテナ技術の普及により、ベアメタルのサーバをベースとした環境だけに留まらなくなってきている。
また、ブルーグリーンデプロイメントといったクラウド環境のメリットを生かしたリリース手法に加え、
開発環境からステージング環境、プロダクション環境へのリリースをパイプライン化して可視化する、
AWS CodePipelineなどのツールも活用の機会が増えつつある。


マイクロサービスアーキテクチャにおける基盤構築自動化・継続的インテグレーション
-------------------------------------------------------------------------------------------------------------------------------------

こうした状況の中で、近年、疎結合性・独立性を重視し、開発におけるアジリティを向上させるマイクロサービスアーキテクチャが
基盤構築の自動化・継続的インテグレーションにも変化をもたらしつつある。というのも、従来のモノリシックなアプリケーション
(全ての機能が一つのアプリケーションパッケージにまとまっている形)に比べ、アプリケーションの構成はもとより、
チーム間での開発体制からリリースの単位までこれまでとは異なる形で行うことを要求されるからである。
マイクロサービスアーキテクチャでは、影響を局所化し、開発におけるアジリティを実現するために、
以下のようにアプリケーションを構成・開発することが要求される。

* アプリケーションは複数のマイクロサービスで構成する。各サービス単位にチームが分けられ、リリース・デプロイまでの開発プロセスを独立して構築する。
* 各サービスはコンテナをベースに構築され、各サービスそれぞれがスケーリング可能な形でデプロイされる。

こうした近年のトレンドに基づいたアプリケーション構成、基盤自動化/継続的インテグレーション・デリバリを実現する例を実際に構築してみる。

.. figure:: img/automation_infra_devops_overview/MicroServiceArchitecture.png
   :scale: 100%

[アプリケーションの構成]

* アプリケーションはAmazonWebService上に構築するWebアプリケーションとする。
* アプリケーションはフロントエンドとバックエンドのサービスに分割し、各サービスはAWS ECSコンテナ上にデプロイされるものとする。
* ECSコンテナ内の各サービスは組み込みTomcatを内蔵するSpringBootアプリケーションで構築する。
* 各サービス間はRESTベースのHTTPリクエストでメッセージ通信を行い、ApplicationLoadBalancerを介して負荷分散する。

なお、サービスをフロントエンドとバックエンドに分割するのは以下の理由・目的のためである。

[フロントエンドの役割]

* サービスマッピング(IP・ポート)
* ブラウザからHTTPメソッド変換(GET・POST⇔GET・POST・PUT・DELETE・OPTION)
* セッション共有(キャッシュサーバ)
* セキュリティ
   * 認証・認可
   * 入力チェック
   * バックエンドサービスURIの隠蔽
   * クライアント⇔バックエンドの直接アクセス禁止
* クラウド依存処理の集約(S3アクセス等)

[バックエンドの役割]

* RESTfulアーキテクチャインターフェース(GET/POST/PUT/DELETE)
* Resource Base URI (/api/v1/users/1)
* 冪等性の実現
* ステートレスの実現

また、サービスがECSコンテナにより管理、ApplicationLoadBalancerを介することで、以下の面がカバーされるようになる。

* ヘルスチェックによるサービス監視
* サービスディスカバリ(ヘルスチェックでNGだと再起動)
* ロードバランシング
* ハードリソース調整/監視(CloudWatch)
* パスベースルーティング

こうしたアプリケーション実行環境の構成は、AWS CloudFormationやTerraformを使って自動構築することができる。

DevOpsとして、下記のようなサイクルでステージング・プロダクション環境へリリースするパイプラインを構成する。

.. figure:: img/automation_infra_devops_overview/ContinuousDeployment.png
   :scale: 100%

AWS CodePipelineを用いて、GitHub上のDevelopブランチへソースコードをコミットもしくはプルリクエストに対し、
AWS CodeBuildを使って、ビルド・テスト・インスペクションを実行し、コンテナイメージを作成して、DockerHub上へプッシュ、
アプリケーションをステージング環境のAWS ECSへデプロイさせる一連の流れを自動化する。

ステージング環境での検証の後、改めてGitHubのMasterブランチへソースコードをコミットもしくはプルリクエストに対し、
同様にプロダクション環境へのリリースを自動化して行う。
