.. include:: module.txt

.. _section-automation-infra-devops-overview-label:

ソフトウェア開発自動化
==================================================================

第四回 基盤・デプロイの自動化
------------------------------------------------------------------

第一回から第三回までの連載では、コーディング、テストの自動化についてそれぞれ解説してきました。
今回は、基盤・デプロイの自動化に関する最近の動向および、基盤自動化・継続的インテグレーション・デリバリ(CI/CD)を
実際に実現する例について概要を説明します。

.. list-table:: 4つの自動化領域
   :widths: 1, 4, 4, 1

   * - No
     - 対象領域
     - 内容
     - 本稿の対象
   * - 1
     - コーディングの自動化
     - 複雑・多様なロジックの自動生成
     -
   * - 2
     - テストの自動化
     - 試験項目の自動生成と自動実行
     -
   * - 3
     - ビルド・リリースの自動化
     - ビルドやテスト環境へのリリースの自動化
     - ◯
   * - 4
     - システム基盤構築の自動化
     - システム基盤の自動インストール・設定
     - ◯


本稿では、基盤自動化、継続的インテグレーション・デリバリの発展経緯を整理します。
その後、最近の新しい動向であるマイクロサービスアーキテクチャベースのアプリケーションのCI/CD
およびアプリケーション基盤構築の実現例の概要を述べます。

|br|

基盤構築自動化の発展経緯
------------------------------------------------------------------

|br|
ロードバランサやアプリケーションサーバ、データベースサーバ、監視サーバといったアプリケーション実行環境を
自動構築するニーズは、仮想化技術の進展とともに、Amazon Web ServiceといったIaaSや、Openstackなどの
クラウドコンピューティングオープンソースソフトウェアの登場により高まりをみせてきました。

従来、企業が自社のデータセンタへ各々サーバを導入し、アプリケーション実行環境を構築する場合は、一度環境を作ってしまえば、その後、ゼロから作り替えたりするケースは稀でした。
しかし、クラウド環境下では、様々なユーザが、仮想マシン上にゲストOSを `プロビジョニング <https://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AD%E3%83%93%E3%82%B8%E3%83%A7%E3%83%8B%E3%83%B3%E3%82%B0>`_ する形態となり、
メンテナンス等でOSを停止するたびにアプリケーション環境は破棄され、同一の実行環境を繰り返し、構築することになります。

それらに加えて、オートスケールなど、サーバリソースを動的に増減できるクラウドならではの特徴が、`イミュータブルインフラストラクチャ <https://ja.wikipedia.org/wiki/Immutable_Infrastructure>`_
といった概念(一度サーバ環境を構築した後は、特に変更など加えず、破棄して新しく作り変える考え方)をもたらしました。
こうした背景のもと、アプリケーション環境構築の作業品質や実行スピードの向上を目的に、アプリケーション環境構築作業をコード化して実行する手段(Infrastructure As Code)として、
サーバ・ミドルウェア環境を自動構築できる、「Puppet」、「Ansible」、「Chef」といった構成管理ツールが普及していくようになります。

一方、仮想化技術は発展を続け、OSを丸ごと実行するハイパーバイザ型と比べて、ハードウェアリソースの消費コストが小さい
Dockerなどのコンテナ技術が発達し、近年広く普及しつつあります。また、Kubernetesなどの
コンテナのリソース管理・スケール調整などを行い、大規模なコンテナアプリケーション実行環境を管理する
オーケストレションツールが脚光を浴びています。このようなアプリケーション実行環境全体の包括的な
Infrastructure As Codeのツールとして、「Amazon Cloud Formation」や「Terraform」を使った
基盤構築のコード化が近年のトレンドとなっています。

|br|


継続的インテグレーション、継続的デリバリの発展
-------------------------------------------------------------------------------------------------------

|br|

他方、継続的インテグレーション(Continuous Integration:CI)・継続的デリバリ(Continuous Delivery:CD)では、
オープンソースソフトウェアのJenkinsを中心として、

#. GitHubなどのソースコードチェックアウト
#. Maven/Gradleなどのビルドツールの実行
#. JUnitなどのテストコードを用いたテスト実行
#. 静的解析ツールを用いたインスペクション
#. 商用環境サーバやライブラリ管理ツールへのデプロイ

といった一連のソフトウェア開発・リリースサイクルを自動化する手法が主流として発展してきましたが、
こちらも仮想化技術やコンテナ技術の普及により、物理サーバを中心とした単一のサーバ環境だけに留まらなくなってきています。
また、`ブルーグリーンデプロイメント <https://www.nttpc.co.jp/yougo/%E3%83%96%E3%83%AB%E3%83%BC%E3%82%B0%E3%83%AA%E3%83%BC%E3%83%B3%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4%E3%83%A1%E3%83%B3%E3%83%88.html>`_ といった、クラウド環境のメリットを生かして、ローリングアップデートするリリース手法に加え、
アプリケーション実行環境のマルチコンテナ化により、構成が複雑化するCI/CD実行環境において、ステージング環境・プロダクション環境への一連のリリースサイクルをパイプライン化して可視化する、
AWS CodePipelineなどのツールも活用の機会が増えつつあります。

|br|

マイクロサービスにおける基盤自動化・継続的インテグレーション・デリバリ
-------------------------------------------------------------------------------------------------------------------------------------

|br|

こうした状況の中で、疎結合性・独立性を重視し、開発のアジリティを向上させるマイクロサービスアーキテクチャが
基盤構築の自動化・継続的インテグレーションにも変化をもたらしつつあります。というのも、従来のモノリシックなアプリケーション
(全ての機能が一つのアプリケーションパッケージにまとまっている形)に比べ、アプリケーション構成はもとより、
チーム間での開発体制からリリースの単位までこれまでとは異なる形で行うことを要求されるからです。
マイクロサービスアーキテクチャでは、サービス間で影響を局所化し、開発におけるアジリティ向上を実現するために、
以下のようにアプリケーションを構成・開発することが要求されるケースが多いです。

* アプリケーションは複数のマイクロサービスで構成する。各サービス単位にチームが分けられ、リリース・デプロイまでの開発プロセスを独立して構築する。
* 多数のサービスはコンテナをベースに構築され、各サービスそれぞれがスケーリング可能な形でデプロイされる。

こうした近年のトレンドに基づき、マイクロサービスアーキテクチャのアプリケーション構成、基盤自動化/継続的インテグレーション・デリバリを実現する例を実際に見てみましょう。

.. figure:: img/automation_infra_devops_overview/MicroServiceArchitecture.png
   :scale: 100%

[アプリケーションの構成]

* アプリケーションはAmazon Web Service上に構築するWebアプリケーションとする。
* アプリケーションはフロントエンドとバックエンドのサービスに分割し、各サービスはAWS ECSコンテナ上にデプロイされるものとする。
* ECSコンテナ内の各サービスは組み込みTomcatを内蔵するSpringBootアプリケーションで実装する。
* 各サービス間はRESTベースのHTTPリクエストでメッセージ通信を行い、ApplicationLoadBalancerを介して負荷分散する。

なお、サービスをフロントエンドとバックエンドに分割するのは以下の理由・目的のためです。

[フロントエンドの役割]

* サービスマッピング(IP・ポート)
* ブラウザからHTTPメソッド変換(GET・POST⇔GET・POST・PUT・DELETE・OPTION)
* セッション共有(キャッシュサーバ)
* セキュリティ
   * 認証・認可
   * 入力チェック
   * バックエンドサービスURIの隠蔽
   * クライアント⇔バックエンドの直接アクセス禁止
* クラウド依存処理の集約(S3アクセス等)

なお、クライアントはSPA(シングルページアーキテクチャ)で、サーバ側は単純なAPIを提供する場合など、フロントエンド部分をAPI Gatewayなどの商用のプロダクト・サービスで代替する例も多くあります。

[バックエンドの役割]

* RESTfulアーキテクチャインターフェース(GET/POST/PUT/DELETE/OPTIONS)
* Resource Base URI (/api/v1/users/1)
* 冪等性の実現
* ステートレスの実現
* データベースなどセキュリティ的に保護する必要があるリソースへのアクセス

また、サービスがECSコンテナにより管理、ApplicationLoadBalancerを介することで、以下の面がカバーされるようになります。

* ヘルスチェックによるサービス監視
* サービスディスカバリ(ヘルスチェックでNGだと再起動)
* ロードバランシング
* ハードリソース調整/監視(CloudWatch)
* パスベースルーティング

こうしたアプリケーション実行環境の構成は、AWS CloudFormationやTerraformを使って自動構築することができます。

DevOpsとして、下記のように、各サービスを構成するマルチコンテナ環境下でのステージング・
プロダクション環境へのデプロイまでの一連のサイクルを可視化するパイプラインを構成できます。

.. figure:: img/automation_infra_devops_overview/ContinuousDeployment.png
   :scale: 100%

AWS CodePipelineを用いて、GitHub上のDevelopブランチへソースコードをコミットもしくはプルリクエストに対し、
AWS CodeBuildを使って、ビルド・テスト・インスペクションを実行し、コンテナイメージを作成して、DockerHub上へプッシュ、
アプリケーションをステージング環境のAWS ECSへデプロイさせる一連の流れを自動化・可視化します。
ステージング環境での検証の後、テストしたアプリケーションのプロダクション環境へのリリースを自動化して行います。

まとめ
------------------------------------------------------------------

これまで基盤自動化・ビルド・リリースの自動化は仮想化技術とともに発展してきました。
さらに、近年の動向であるマイクロサービスアーキテクチャが進むことにより、更なる進化が進みつつあります。
今後の自動化はアーキテクチャ・基盤・リリースプロセスを一体として考え、構築していく必要がありそうです。
